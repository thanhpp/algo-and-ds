pub struct Solution {}

impl Solution {
    pub fn num_islands(mut grid: Vec<Vec<char>>) -> i32 {
        let mut island = 0;
        let rows_length = grid.len();
        let cols_length = grid[0].len();
        let mut queue = std::collections::VecDeque::<(usize, usize)>::new();

        for r in 0..rows_length {
            for c in 0..cols_length {
                if grid[r][c] != '1' {
                    continue;
                }

                queue.push_back((r, c));
                island += 1;

                while !queue.is_empty() {
                    let (row, col) = match queue.pop_back() {
                        None => break,
                        Some((row, col)) => (row, col),
                    };
                    // visited
                    grid[row][col] = 'x';

                    if row > 0 && grid[row - 1][col] == '1' {
                        println!("{} {} {} {}", row, col, row - 1, col);
                        queue.push_back((row - 1, col))
                    }
                    if row < rows_length - 1 && grid[row + 1][col] == '1' {
                        println!("{} {} {} {}", row, col, row + 1, col);
                        queue.push_back((row + 1, col))
                    }

                    if col > 0 && grid[row][col - 1] == '1' {
                        println!("{} {} {} {}", row, col, row, col - 1);
                        queue.push_back((row, col - 1))
                    }
                    if col < cols_length - 1 && grid[row][col + 1] == '1' {
                        println!("{} {} {} {}", row, col, row, col + 1);
                        queue.push_back((row, col + 1))
                    }
                }
            }
        }

        island
    }
}

mod test {
    use crate::Solution;

    #[test]
    fn test_1() {
        let grid = vec![
            [
                '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0',
                '1', '0', '1', '1',
            ],
            [
                '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1',
                '1', '1', '1', '0',
            ],
            [
                '1', '0', '1', '1', '1', '0', '0', '1', '1', '0', '1', '1', '1', '1', '1', '1',
                '1', '1', '1', '1',
            ],
            [
                '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',
                '1', '1', '1', '1',
            ],
            [
                '1', '0', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',
                '1', '1', '1', '1',
            ],
            [
                '1', '0', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1',
                '0', '1', '1', '1',
            ],
            [
                '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '0',
                '1', '1', '1', '1',
            ],
            [
                '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1',
                '1', '0', '1', '1',
            ],
            [
                '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1',
                '1', '1', '1', '1',
            ],
            [
                '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',
                '1', '1', '1', '1',
            ],
            [
                '0', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1',
                '1', '1', '1', '1',
            ],
            [
                '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',
                '1', '1', '1', '1',
            ],
            [
                '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',
                '1', '1', '1', '1',
            ],
            [
                '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1',
                '1', '1', '1', '1',
            ],
            [
                '1', '0', '1', '1', '1', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1', '1',
                '0', '1', '1', '1',
            ],
            [
                '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1',
                '1', '1', '1', '0',
            ],
            [
                '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1',
                '1', '1', '0', '0',
            ],
            [
                '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',
                '1', '1', '1', '1',
            ],
            [
                '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',
                '1', '1', '1', '1',
            ],
            [
                '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',
                '1', '1', '1', '1',
            ],
        ];

        let grid: Vec<Vec<char>> = grid.iter().map(|r| r.to_vec()).collect();

        let island = Solution::num_islands(grid);

        println!("{}", island);
    }
}
